// TypeScript interface for Rust WebAssembly engine
export interface TextAnalysisResult {
  word_count: number;
  character_count: number;
  paragraph_count: number;
  sentence_count: number;
  readability_score: number;
  complexity_metrics: ComplexityMetrics;
  style_metrics: StyleMetrics;
  content_hash: string;
}

export interface ComplexityMetrics {
  avg_words_per_sentence: number;
  avg_syllables_per_word: number;
  fog_index: number;
  flesch_reading_ease: number;
  unique_word_ratio: number;
}

export interface StyleMetrics {
  passive_voice_ratio: number;
  adverb_ratio: number;
  dialogue_ratio: number;
  action_ratio: number;
  description_ratio: number;
}

export interface OptimizationSuggestion {
  suggestion_type: string;
  priority: string;
  message: string;
  start_pos: number;
  end_pos: number;
  suggested_replacement?: string;
}

export interface CollaborationConflict {
  conflict_id: string;
  conflict_type: string;
  start_pos: number;
  end_pos: number;
  user_a_change: string;
  user_b_change: string;
  timestamp: string;
  resolution_suggestion: string;
}

class RustEngineWrapper {
  private wasmModule: any = null;
  private textProcessor: any = null;
  private isInitialized = false;

  async initialize(): Promise<void> {
    if (this.isInitialized) return;

    try {
      // Import the WASM module (will be generated by Rust build)
      const wasmModule = await import('../wasm/omniauthor-engine.js');
      await wasmModule.default();
      
      this.wasmModule = wasmModule;
      this.textProcessor = new wasmModule.TextProcessor();
      this.isInitialized = true;
      
      console.log('Rust engine initialized successfully');
    } catch (error) {
      console.warn('Rust engine not available, falling back to JS implementation:', error);
      this.initializeFallback();
    }
  }

  private initializeFallback(): void {
    // Fallback JavaScript implementation for when Rust WASM is not available
    this.textProcessor = {
      analyze_text: (text: string) => this.fallbackAnalyzeText(text),
      optimize_text: (text: string) => this.fallbackOptimizeText(text),
      resolve_conflicts: (conflicts: CollaborationConflict[]) => this.fallbackResolveConflicts(conflicts),
      generate_content_hash: (text: string) => this.fallbackGenerateHash(text),
    };
    this.isInitialized = true;
  }

  async analyzeText(text: string): Promise<TextAnalysisResult> {
    if (!this.isInitialized) await this.initialize();
    
    if (this.wasmModule) {
      return this.textProcessor.analyze_text(text);
    } else {
      return this.textProcessor.analyze_text(text);
    }
  }

  async optimizeText(text: string): Promise<OptimizationSuggestion[]> {
    if (!this.isInitialized) await this.initialize();
    
    if (this.wasmModule) {
      return this.textProcessor.optimize_text(text);
    } else {
      return this.textProcessor.optimize_text(text);
    }
  }

  async resolveConflicts(conflicts: CollaborationConflict[]): Promise<CollaborationConflict[]> {
    if (!this.isInitialized) await this.initialize();
    
    if (this.wasmModule) {
      return this.textProcessor.resolve_conflicts(conflicts);
    } else {
      return this.textProcessor.resolve_conflicts(conflicts);
    }
  }

  async generateContentHash(text: string): Promise<string> {
    if (!this.isInitialized) await this.initialize();
    
    if (this.wasmModule) {
      return this.textProcessor.generate_content_hash(text);
    } else {
      return this.textProcessor.generate_content_hash(text);
    }
  }

  // Fallback implementations
  private fallbackAnalyzeText(text: string): TextAnalysisResult {
    const words = text.match(/\b\w+\b/g) || [];
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim().length > 0);
    
    const wordCount = words.length;
    const characterCount = text.length;
    const sentenceCount = sentences.length;
    const paragraphCount = paragraphs.length;
    
    const avgWordsPerSentence = sentenceCount > 0 ? wordCount / sentenceCount : 0;
    const avgSyllablesPerWord = 1.5; // Simplified estimate
    const fleschScore = 206.835 - 1.015 * avgWordsPerSentence - 84.6 * avgSyllablesPerWord;
    
    return {
      word_count: wordCount,
      character_count: characterCount,
      paragraph_count: paragraphCount,
      sentence_count: sentenceCount,
      readability_score: fleschScore,
      complexity_metrics: {
        avg_words_per_sentence: avgWordsPerSentence,
        avg_syllables_per_word: avgSyllablesPerWord,
        fog_index: 0.4 * (avgWordsPerSentence + 100 * 0.1),
        flesch_reading_ease: fleschScore,
        unique_word_ratio: new Set(words.map(w => w.toLowerCase())).size / wordCount,
      },
      style_metrics: {
        passive_voice_ratio: 0.1,
        adverb_ratio: 0.05,
        dialogue_ratio: 0.2,
        action_ratio: 0.3,
        description_ratio: 0.4,
      },
      content_hash: this.fallbackGenerateHash(text),
    };
  }

  private fallbackOptimizeText(text: string): OptimizationSuggestion[] {
    const suggestions: OptimizationSuggestion[] = [];
    
    // Find long sentences
    const sentences = text.split(/[.!?]+/);
    sentences.forEach((sentence, index) => {
      const words = sentence.match(/\b\w+\b/g) || [];
      if (words.length > 25) {
        suggestions.push({
          suggestion_type: 'sentence_length',
          priority: 'medium',
          message: 'Consider breaking this long sentence into shorter ones.',
          start_pos: index * 50,
          end_pos: (index + 1) * 50,
        });
      }
    });
    
    return suggestions;
  }

  private fallbackResolveConflicts(conflicts: CollaborationConflict[]): CollaborationConflict[] {
    return conflicts.map(conflict => ({
      ...conflict,
      resolution_suggestion: `Auto-resolved: ${conflict.user_b_change}`,
    }));
  }

  private fallbackGenerateHash(text: string): string {
    // Simple hash function for fallback
    let hash = 0;
    for (let i = 0; i < text.length; i++) {
      const char = text.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash).toString(16);
  }
}

// Export singleton instance
export const rustEngine = new RustEngineWrapper();